From 33cf2205f25c1ec57fae14c6149964c4cf0de7f3 Mon Sep 17 00:00:00 2001
From: Jaegeuk Kim <jaegeuk@kernel.org>
Date: Tue, 31 Jan 2017 18:16:30 -0800
Subject: [PATCH 2/3] f2fs-dev: emulate atomic writes for checkpoint and
 atomic_writes

Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>
---
 fs/f2fs/checkpoint.c |  2 +-
 fs/f2fs/data.c       | 10 ++++++++--
 fs/f2fs/f2fs.h       |  4 ++--
 fs/f2fs/node.c       | 33 ++++++++++++++++-----------------
 fs/f2fs/segment.c    | 27 +++++++++++++--------------
 fs/f2fs/segment.h    |  4 +++-
 6 files changed, 43 insertions(+), 37 deletions(-)

diff --git a/fs/f2fs/checkpoint.c b/fs/f2fs/checkpoint.c
index 800be94f8cb3..80c329f8bf4e 100644
--- a/fs/f2fs/checkpoint.c
+++ b/fs/f2fs/checkpoint.c
@@ -1245,7 +1245,7 @@ static int do_checkpoint(struct f2fs_sb_info *sbi, struct cp_control *cpc)
 
 	clear_sbi_flag(sbi, SBI_IS_DIRTY);
 	clear_sbi_flag(sbi, SBI_NEED_CP);
-	__set_cp_next_pack(sbi);
+	//__set_cp_next_pack(sbi);
 
 	/*
 	 * redirty superblock if metadata like node page or inode cache is
diff --git a/fs/f2fs/data.c b/fs/f2fs/data.c
index c2b98e44c5f3..73e46443e081 100644
--- a/fs/f2fs/data.c
+++ b/fs/f2fs/data.c
@@ -1333,8 +1333,8 @@ static inline bool need_inplace_update(struct f2fs_io_info *fio)
 {
 	if (is_cold_data(fio->page))
 		return false;
-	if (IS_ATOMIC_WRITTEN_PAGE(fio->page))
-		return false;
+//	if (IS_ATOMIC_WRITTEN_PAGE(fio->page))
+//		return false;
 
 	return need_inplace_update_policy(fio->page->mapping->host, fio);
 }
@@ -1345,6 +1345,12 @@ static inline bool valid_ipu_blkaddr(struct f2fs_io_info *fio)
 		return false;
 	if (fio->old_blkaddr == NULL_ADDR)
 		return false;
+	if (IS_ATOMIC_WRITTEN_PAGE(fio->page) && fio->sbi->s_ndevs > 1) {
+		struct f2fs_sb_info *sbi = fio->sbi;
+
+		if (fio->old_blkaddr > FDEV(0).end_blk)
+			return false;
+	}
 	return true;
 }
 
diff --git a/fs/f2fs/f2fs.h b/fs/f2fs/f2fs.h
index bf48213642ab..9843939e25fe 100644
--- a/fs/f2fs/f2fs.h
+++ b/fs/f2fs/f2fs.h
@@ -1498,8 +1498,8 @@ static inline block_t __start_cp_next_addr(struct f2fs_sb_info *sbi)
 {
 	block_t start_addr = le32_to_cpu(F2FS_RAW_SUPER(sbi)->cp_blkaddr);
 
-	if (sbi->cur_cp_pack == 1)
-		start_addr += sbi->blocks_per_seg;
+//	if (sbi->cur_cp_pack == 1)
+//		start_addr += sbi->blocks_per_seg;
 	return start_addr;
 }
 
diff --git a/fs/f2fs/node.c b/fs/f2fs/node.c
index b99e318bce58..4f9489a13224 100644
--- a/fs/f2fs/node.c
+++ b/fs/f2fs/node.c
@@ -107,30 +107,29 @@ static struct page *get_current_nat_page(struct f2fs_sb_info *sbi, nid_t nid)
 static struct page *get_next_nat_page(struct f2fs_sb_info *sbi, nid_t nid)
 {
 	struct page *src_page;
-	struct page *dst_page;
+	//struct page *dst_page;
 	pgoff_t src_off;
-	pgoff_t dst_off;
-	void *src_addr;
-	void *dst_addr;
-	struct f2fs_nm_info *nm_i = NM_I(sbi);
+	//pgoff_t dst_off;
+	//void *src_addr;
+	//void *dst_addr;
 
 	src_off = current_nat_addr(sbi, nid);
-	dst_off = next_nat_addr(sbi, src_off);
+	//dst_off = next_nat_addr(sbi, src_off);
 
 	/* get current nat block page with lock */
 	src_page = get_meta_page(sbi, src_off);
-	dst_page = grab_meta_page(sbi, dst_off);
-	f2fs_bug_on(sbi, PageDirty(src_page));
+	//dst_page = grab_meta_page(sbi, dst_off);
+	//f2fs_bug_on(sbi, PageDirty(src_page));
 
-	src_addr = page_address(src_page);
-	dst_addr = page_address(dst_page);
-	memcpy(dst_addr, src_addr, PAGE_SIZE);
-	set_page_dirty(dst_page);
-	f2fs_put_page(src_page, 1);
+	//src_addr = page_address(src_page);
+	//dst_addr = page_address(dst_page);
+	//memcpy(dst_addr, src_addr, PAGE_SIZE);
+	set_page_dirty(src_page);
+	//f2fs_put_page(src_page, 1);
 
-	set_to_next_nat(nm_i, nid);
+//	set_to_next_nat(nm_i, nid);
 
-	return dst_page;
+	return src_page;
 }
 
 static struct nat_entry *__lookup_nat_cache(struct f2fs_nm_info *nm_i, nid_t n)
@@ -1362,8 +1361,8 @@ static int __write_node_page(struct page *page, bool atomic, bool *submitted,
 		return 0;
 	}
 
-	if (atomic && !test_opt(sbi, NOBARRIER))
-		fio.op_flags |= REQ_PREFLUSH | REQ_FUA;
+//	if (atomic && !test_opt(sbi, NOBARRIER))
+//		fio.op_flags |= REQ_PREFLUSH | REQ_FUA;
 
 	set_page_writeback(page);
 	fio.old_blkaddr = ni.blk_addr;
diff --git a/fs/f2fs/segment.c b/fs/f2fs/segment.c
index 9913a2088148..2389d16a1c7d 100644
--- a/fs/f2fs/segment.c
+++ b/fs/f2fs/segment.c
@@ -2582,29 +2582,28 @@ static struct page *get_current_sit_page(struct f2fs_sb_info *sbi,
 static struct page *get_next_sit_page(struct f2fs_sb_info *sbi,
 					unsigned int start)
 {
-	struct sit_info *sit_i = SIT_I(sbi);
-	struct page *src_page, *dst_page;
-	pgoff_t src_off, dst_off;
-	void *src_addr, *dst_addr;
+	struct page *src_page; //, *dst_page;
+	pgoff_t src_off; //, dst_off;
+//	void *src_addr; //, *dst_addr;
 
 	src_off = current_sit_addr(sbi, start);
-	dst_off = next_sit_addr(sbi, src_off);
+//	dst_off = next_sit_addr(sbi, src_off);
 
 	/* get current sit block page without lock */
 	src_page = get_meta_page(sbi, src_off);
-	dst_page = grab_meta_page(sbi, dst_off);
-	f2fs_bug_on(sbi, PageDirty(src_page));
+//	dst_page = grab_meta_page(sbi, dst_off);
+//	f2fs_bug_on(sbi, PageDirty(src_page));
 
-	src_addr = page_address(src_page);
-	dst_addr = page_address(dst_page);
-	memcpy(dst_addr, src_addr, PAGE_SIZE);
+//	src_addr = page_address(src_page);
+//	dst_addr = page_address(dst_page);
+//	memcpy(dst_addr, src_addr, PAGE_SIZE);
 
-	set_page_dirty(dst_page);
-	f2fs_put_page(src_page, 1);
+	set_page_dirty(src_page);
+//	f2fs_put_page(src_page, 1);
 
-	set_to_next_sit(sit_i, start);
+//	set_to_next_sit(sit_i, start);
 
-	return dst_page;
+	return src_page;
 }
 
 static struct sit_entry_set *grab_sit_entry_set(void)
diff --git a/fs/f2fs/segment.h b/fs/f2fs/segment.h
index c51273c0c1ef..4b7465a01845 100644
--- a/fs/f2fs/segment.h
+++ b/fs/f2fs/segment.h
@@ -571,8 +571,10 @@ static inline bool need_inplace_update_policy(struct inode *inode,
 	unsigned int policy = SM_I(sbi)->ipu_policy;
 
 	/* IPU can be done only for the user data */
-	if (S_ISDIR(inode->i_mode) || f2fs_is_atomic_file(inode))
+	if (S_ISDIR(inode->i_mode)) // || f2fs_is_atomic_file(inode))
 		return false;
+	if (f2fs_is_atomic_file(inode))
+		return true;
 
 	if (test_opt(sbi, LFS))
 		return false;
-- 
2.11.0

